{
    "docs": [
        {
            "location": "/", 
            "text": "LISA Api is a core component of LISA. It's based on Django Rest Framework that makes it easy to build Web APIs for almost everything.\n\n\nThe API was made to provide an easy bridge between custom home automation devices which are not zwave or having a common protocol.\nIf your device can be reach and used by python, so you can expose a http endpoint and it will be useable by your home automation box.\n\n\nSome key features :\n\n\n\n\nHighly customizable, you can easily override native functions using your plugins\n\n\nPlugins are easy to write, and can be auto-generated\n\n\nPlugins can provide a generic interface to let other plugins plug on them\n\n\nPlugins dependancies\n\n\nAuto-generated documentation\n\n\n\n\n\n\nRequirements\n\n\nLISA API requires the following:\n\n\n\n\nPython (2.7, 3.4)\n\n\nDjango (1.8)\n\n\nDjango Rest Framework\n\n\nPIP\n\n\nDjango Rest Swagger\n\n\nStevedore\n\n\nColorlog\n\n\nKombu\n\n\nRequests\n\n\n\n\nQuickstart\n\n\nCan't wait to get started? The \nquickstart guide\n is the fastest way to get up and running, and creating plugins.\n\n\nTutorial\n\n\nThe tutorial will walk you through the building blocks that make up REST framework.   It'll take a little while to get through, but it'll give you a comprehensive understanding of how everything fits together, and is highly recommended reading.\n\n\n\n\n1 - Plugins\n\n\n\n\nDevelopment\n\n\nSee the \nContribution guidelines\n for information on how to clone\nthe repository, run the test suite and contribute changes back to LISA API.\n\n\nSupport\n\n\nFor support please see the \nask website\n, try the channel on \ngitter\n\n\nLicense\n\n\nCopyright (c) 2015, Julien Syx\nAll rights reserved.\n\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the\nfollowing conditions are met:\n\n\n\n\n\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following\ndisclaimer.\n\n\n\n\n\n\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following\ndisclaimer in the documentation and/or other materials provided with the distribution.\n\n\n\n\n\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\nWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\nTHIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.", 
            "title": "Home"
        }, 
        {
            "location": "/#requirements", 
            "text": "LISA API requires the following:   Python (2.7, 3.4)  Django (1.8)  Django Rest Framework  PIP  Django Rest Swagger  Stevedore  Colorlog  Kombu  Requests", 
            "title": "Requirements"
        }, 
        {
            "location": "/#quickstart", 
            "text": "Can't wait to get started? The  quickstart guide  is the fastest way to get up and running, and creating plugins.", 
            "title": "Quickstart"
        }, 
        {
            "location": "/#tutorial", 
            "text": "The tutorial will walk you through the building blocks that make up REST framework.   It'll take a little while to get through, but it'll give you a comprehensive understanding of how everything fits together, and is highly recommended reading.   1 - Plugins", 
            "title": "Tutorial"
        }, 
        {
            "location": "/#development", 
            "text": "See the  Contribution guidelines  for information on how to clone\nthe repository, run the test suite and contribute changes back to LISA API.", 
            "title": "Development"
        }, 
        {
            "location": "/#support", 
            "text": "For support please see the  ask website , try the channel on  gitter", 
            "title": "Support"
        }, 
        {
            "location": "/#license", 
            "text": "Copyright (c) 2015, Julien Syx\nAll rights reserved.  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the\nfollowing conditions are met:    Redistributions of source code must retain the above copyright notice, this list of conditions and the following\ndisclaimer.    Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following\ndisclaimer in the documentation and/or other materials provided with the distribution.    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\nWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\nTHIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.", 
            "title": "License"
        }, 
        {
            "location": "/tutorial/quickstart/", 
            "text": "Quickstart\n\n\nDocker - I just want to test !\n\n\nIt's really simple to test the API very quickly by using \ndocker\n.\n\n\nInstall \ndocker\n on your host, then launch :\n\n\ndocker run  --publish=8001:8000 -d --name lisa-api seraf/lisa-api\n\n\n\n\nThen, you can access \nhttp://localhost:8001/api-auth/login/\n (if docker is on your localhost)\n\n\nThe login and pass of this image is \nadmin\n/\nadmin\n.\n\n\nYou can find the docker repository \nhere\n\n\nAnsible - I want to automatize the deployment\n\n\nAnsible\n\n\nYou may want to have a machine to \npilot\n all the LISA components. And it's a good idea !\n\n\nFor that, we will use \nAnsible\n. A \nrole has been created\n to install the required packages to your api host.\n\n\nYou have to install Ansible. It's up to you to install the package of your linux distribution or to install it with \npip\n.\n\n\nInstall Ansible Role\n\n\nFirst, we will install the \nlisa-api role\n :\n\n\nansible-galaxy install Seraf.lisa-api\n\n\n\n\nWhat is in the stack ?\n\n\nThis role will deploy a stack on your server with :\n\n\n\n\nRabbitmq\n : to have a messaging server used for communication between client and api\n\n\nPython\n : it will install the python package of your distribution\n\n\nVirtualenv\n : it will create a user/group named \nalivelisa\n and create a virtual environment in \n/home/alivelisa\n\n\nSupervisord\n : it is a daemon which ensure a process is always running. Instead of creating a service for LISA, supervisord will manage the process\n\n\n\n\nThe only component you may need to install is the \nmysql-server\n. I did the choice to not install it as you need to setup a root account and you may want specific credentials for the \nlisa_api\n user.\n\n\nConfigure your Ansible\n\n\nFor this part, you should find most of the documentation on \nAnsible website\n. We will cover only the needed parts.\n\n\nYou need to tell to Ansible which host is a lisa-api.\n\n\nFor this, edit the file \n/etc/ansible/hosts\n :\n\n\n[lisa-api]\n192.168.1.85\n\n\n\n\nHere, my host \n192.168.1.85\n is a lxc container.\n\n\nIf you have no ssh key, create one :\n\n\nssh-keygen -t rsa\n\n\n\n\nYou also need to copy your ssh key to the host to have a passwordless connection.\nThis command will ask you the password of the root account of the remote host :\n\n\nssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.1.85\n\n\n\n\nNow, you should be able to connect on your host (here \n192.168.1.85\n) without any password :\n\n\nssh root@192.168.1.85\n\n\n\n\nYou can test that ansible is able to join your host :\n\n\nansible lisa-api -m ping\n\n\n\n\nDeploy the role on your server\n\n\nNow, we need to tell to Ansible to apply the role \nSeraf.lisa-api\n on the group \nlisa-api\n.\n\n\nCreate the \nplaybook\n file named \ninstall-lisa-api.yml\n :\n\n\n---\n- hosts: lisa-api\n  roles:\n     - Seraf.lisa-api\n\n\n\n\nThat's all ! You should be able to run it with :\n\n\nansible-playbook install-lisa-api.yml\n\n\n\n\nCreate the configuration file\n\n\nThe API will read by default the configuration files located in \n/etc/lisa/conf/lisa_api.ini\n and \n/home/alivelisa/.virtualenvs/lisa-api/local/lib/python2.7/site-packages/lisa_api/lisa_api.ini\n\n\nAn example of ini file to connect to a default database (used in docker container) :\n\n\n[api]\ndebug = True\n\n[database]\nname = lisa_api\nuser = lisa_api\npassword = lisapassword\nhost = localhost\nport = 3306\n\n[rabbitmq]\nuser = guest\npassword = guest\nhost = localhost\n\n\n\n\nThe api will read the configuration file in two places. One on the system \n/etc\n and another in the userland \n/home\n. It will ensure user who aren't root to be able to modify easily their configuration.\n\n\nCreate the MySQL database\n\n\nAs this part isn't covered by the ansible role, you need to install by yourself the mysql server and configure it.\n\n\nYou will need to create a database :\n\n\ncreate database lisa_api;\n\n\n\n\nAnd the user associated :\n\n\ngrant all privileges on lisa_api.* to 'lisa_api'@'localhost' identified by 'lisapassword';\n\n\n\n\nStart the API\n\n\nYou can connect with ssh on your host to start/stop/restart the api using \nsupervisorctl\n :\n\n\nroot@lxc-lisa-api:~# supervisorctl \nlisa-api                         RUNNING    pid 1406, uptime 4:11:57\nsupervisor\n stop lisa-api\nlisa-api: stopped\nsupervisor\n start lisa-api\nlisa-api: started\n\n\n\n\nOr you can use ansible to do this :\n\n\nansible lisa-api -m supervisorctl -a \nname=lisa-api state=restarted\n\n\n\n\n\nBy Hand - Install for the brave and true\n\n\nIt's the best method to understand what you are doing and which components are required by the api.\n\n\nCreate a user named \nalivelisa\n and a group with the same name :\n\n\nsudo groupadd alivelisa\nsudo useradd -m -g alivelisa alivelisa\n\n\n\n\nInstall tools for virtual environment :\n\n\nsudo pip install virtualenv virtualenvwrapper\n\n\n\n\nCreate the virtual environment :\n\n\nsu - alivelisa\ncd /home/alivelisa\nmkvirtualenv lisa-api\nworkon lisa-api\n\n\n\n\nInstall using \npip\n, including any optional packages you want...\n\n\npip install lisa-api\n\n\n\n...or clone the project from github.\n\n\ngit clone git@github.com:project-lisa/lisa-api.git\n\n\n\nCreate the MySQL user\n\n\ngrant all privileges on lisa_api.* to 'lisa_api'@'localhost' identified by 'lisapassword';\n\n\n\nCreate a configuration file\n\n\nsudo mkdir -p /etc/lisa/conf/\nlisa-api-cli configuration save --filename /etc/lisa/conf/lisa_api.ini\n\n\n\nYou can of course edit these configuration parameters following your needs\n\n\nCreate your super-user\n\n\nlisa-api-cli createsuperuser\n\n\n\nThen launch the lisa-api webserver\n\n\nlisa-api-cli runserver 0.0.0.0:8000\n\n\n\nYou can now access it in your browser by loging in before at \nhttp://127.0.0.1:8000/api-auth/login/\n\n\nhttp://localhost:8000/docs/\n\n\n\nOptionals\n\n\nThere is some optional packages you may need to install :\n\n\n\n\nIf you want to use \npicotts\n : \nlibav-tools\n \nlibttspico-data\n \nlibttspico-utils\n \nlibavcodec-extra-53", 
            "title": "Quickstart"
        }, 
        {
            "location": "/tutorial/quickstart/#quickstart", 
            "text": "", 
            "title": "Quickstart"
        }, 
        {
            "location": "/tutorial/quickstart/#docker-i-just-want-to-test", 
            "text": "It's really simple to test the API very quickly by using  docker .  Install  docker  on your host, then launch :  docker run  --publish=8001:8000 -d --name lisa-api seraf/lisa-api  Then, you can access  http://localhost:8001/api-auth/login/  (if docker is on your localhost)  The login and pass of this image is  admin / admin .  You can find the docker repository  here", 
            "title": "Docker - I just want to test !"
        }, 
        {
            "location": "/tutorial/quickstart/#ansible-i-want-to-automatize-the-deployment", 
            "text": "Ansible  You may want to have a machine to  pilot  all the LISA components. And it's a good idea !  For that, we will use  Ansible . A  role has been created  to install the required packages to your api host.  You have to install Ansible. It's up to you to install the package of your linux distribution or to install it with  pip .  Install Ansible Role  First, we will install the  lisa-api role  :  ansible-galaxy install Seraf.lisa-api  What is in the stack ?  This role will deploy a stack on your server with :   Rabbitmq  : to have a messaging server used for communication between client and api  Python  : it will install the python package of your distribution  Virtualenv  : it will create a user/group named  alivelisa  and create a virtual environment in  /home/alivelisa  Supervisord  : it is a daemon which ensure a process is always running. Instead of creating a service for LISA, supervisord will manage the process   The only component you may need to install is the  mysql-server . I did the choice to not install it as you need to setup a root account and you may want specific credentials for the  lisa_api  user.  Configure your Ansible  For this part, you should find most of the documentation on  Ansible website . We will cover only the needed parts.  You need to tell to Ansible which host is a lisa-api.  For this, edit the file  /etc/ansible/hosts  :  [lisa-api]\n192.168.1.85  Here, my host  192.168.1.85  is a lxc container.  If you have no ssh key, create one :  ssh-keygen -t rsa  You also need to copy your ssh key to the host to have a passwordless connection.\nThis command will ask you the password of the root account of the remote host :  ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.1.85  Now, you should be able to connect on your host (here  192.168.1.85 ) without any password :  ssh root@192.168.1.85  You can test that ansible is able to join your host :  ansible lisa-api -m ping  Deploy the role on your server  Now, we need to tell to Ansible to apply the role  Seraf.lisa-api  on the group  lisa-api .  Create the  playbook  file named  install-lisa-api.yml  :  ---\n- hosts: lisa-api\n  roles:\n     - Seraf.lisa-api  That's all ! You should be able to run it with :  ansible-playbook install-lisa-api.yml  Create the configuration file  The API will read by default the configuration files located in  /etc/lisa/conf/lisa_api.ini  and  /home/alivelisa/.virtualenvs/lisa-api/local/lib/python2.7/site-packages/lisa_api/lisa_api.ini  An example of ini file to connect to a default database (used in docker container) :  [api]\ndebug = True\n\n[database]\nname = lisa_api\nuser = lisa_api\npassword = lisapassword\nhost = localhost\nport = 3306\n\n[rabbitmq]\nuser = guest\npassword = guest\nhost = localhost  The api will read the configuration file in two places. One on the system  /etc  and another in the userland  /home . It will ensure user who aren't root to be able to modify easily their configuration.  Create the MySQL database  As this part isn't covered by the ansible role, you need to install by yourself the mysql server and configure it.  You will need to create a database :  create database lisa_api;  And the user associated :  grant all privileges on lisa_api.* to 'lisa_api'@'localhost' identified by 'lisapassword';  Start the API  You can connect with ssh on your host to start/stop/restart the api using  supervisorctl  :  root@lxc-lisa-api:~# supervisorctl \nlisa-api                         RUNNING    pid 1406, uptime 4:11:57\nsupervisor  stop lisa-api\nlisa-api: stopped\nsupervisor  start lisa-api\nlisa-api: started  Or you can use ansible to do this :  ansible lisa-api -m supervisorctl -a  name=lisa-api state=restarted", 
            "title": "Ansible - I want to automatize the deployment"
        }, 
        {
            "location": "/tutorial/quickstart/#by-hand-install-for-the-brave-and-true", 
            "text": "It's the best method to understand what you are doing and which components are required by the api.  Create a user named  alivelisa  and a group with the same name :  sudo groupadd alivelisa\nsudo useradd -m -g alivelisa alivelisa  Install tools for virtual environment :  sudo pip install virtualenv virtualenvwrapper  Create the virtual environment :  su - alivelisa\ncd /home/alivelisa\nmkvirtualenv lisa-api\nworkon lisa-api  Install using  pip , including any optional packages you want...  pip install lisa-api  ...or clone the project from github.  git clone git@github.com:project-lisa/lisa-api.git  Create the MySQL user  grant all privileges on lisa_api.* to 'lisa_api'@'localhost' identified by 'lisapassword';  Create a configuration file  sudo mkdir -p /etc/lisa/conf/\nlisa-api-cli configuration save --filename /etc/lisa/conf/lisa_api.ini  You can of course edit these configuration parameters following your needs  Create your super-user  lisa-api-cli createsuperuser  Then launch the lisa-api webserver  lisa-api-cli runserver 0.0.0.0:8000  You can now access it in your browser by loging in before at  http://127.0.0.1:8000/api-auth/login/  http://localhost:8000/docs/", 
            "title": "By Hand - Install for the brave and true"
        }, 
        {
            "location": "/tutorial/quickstart/#optionals", 
            "text": "There is some optional packages you may need to install :   If you want to use  picotts  :  libav-tools   libttspico-data   libttspico-utils   libavcodec-extra-53", 
            "title": "Optionals"
        }, 
        {
            "location": "/tutorial/1-plugins/", 
            "text": "Plugins\n\n\nHow it work\n\n\nAs the API is done with \nDjango\n, you will need to understand \nDjango\n to create the plugins.\n\n\nPlugins are created with \nDjango Rest Framework\n (you should read the docs too).\n\n\nEach plugin is a \nDjango Application\n which is dynamically loaded by django using the entry points.\n\n\nAn entry point is a Python object in a project\u2019s code that is identified by a string in the project\u2019s \nsetup.py\n file. The entry point is referenced by a group and a name so that the object may be discoverable. This means that another application can search for all the installed software that has an entry point with a particular group name, and then access the Python object associated with that name.\n\n\nThis is extremely useful because it means it is possible to write plugins for an appropriately-designed application that can be loaded at run time.\n\n\nIt is important to understand that entry points are a feature of the new Python eggs package format and are not a standard feature of Python.\n\n\nThe entry point in our plugin look like :\n\n\nentry_points={\n    'lisa.api.plugins': [\n        'shopping = lisa_plugins_shopping:ShoppingPlugin',\n    ]\n},\n\n\n\nWe register the plugin \nshopping\n in the namespace \nlisa.api.plugins\n and it is mapped to the class \nShoppingPlugin\n in our package (defined in the \n__init__.py\n file).\n\n\nThe \nINSTALLED_APP\n list of Django is populated by the plugin manager which will look for all plugin available in the namespace \nlisa.api.plugins\n and will import all their urls and models.\n\n\nDjango as other framework don't support to add or delete routes at runtime. So the plugins are loaded when the api server is launched.\nWhen a new plugin is installed or removed, the server needs to be restarted. It has been automated by changing the file attribute of \n__init__.py\n so the django server do a reload.\n\n\nStructure\n\n\nA plugin is mainly a Django Application with some added features. By default, it has this structure :\n\n\n\n\ntests\n : it's the directory containing all your unit tests to be sure your plugin will work even if you modify it, or if it works with the new LISA API versions\n\n\nrequirements/requirements-plugin.txt\n : this file contains the libraries required for your plugin (note that it differs from pip dependancies (check the setup.py file)\n\n\nsetup.py\n : this file manage how you're plugin will be installed. You configure your name, and few metadata that will appears on pypi. You will have to edit this file to add entry_points or to add required libraries\n\n\nlisa_plugins_shopping/__init__.py\n : contains metadata about your plugin and the intents mapped to your API.\n\n\nlisa_plugins_shopping/models.py\n : contains the model of your object (optional). This model will be the table in the database you could use\n\n\nlisa_plugins_shopping/serializers.py\n : contains classes to explain to django how to serialize the data received on the API\n\n\nlisa_plugins_shopping/urls.py\n : contains url and the view attached\n\n\nlisa_plugins_shopping/views.py\n : the most important part of your plugin. It contains all the logic and how the data received should be used\n\n\nlisa_plugins_shopping/migrations\n : this directory contains all the evolutions of your model. his directory is automatically managed by django and will provide a very easy system to distribute new version of your plugin\n\n\n\n\nInstall a plugin\n\n\nThe goal is to create a community around LISA. Users will create plugins and share them to others.\n\n\nInstalling a plugin is very simple. You just need to do a HTTP query on the API :\n\n\ncurl -X POST -H \nContent-Type: application/json\n http://localhost:8000/api/v1/core/plugins/ --data '{\nname\n: \nshopping\n}'\n\n\n\n\nCreate your first plugin\n\n\nPlace yourself in the directory where you have permissions to create a directory and would like to work. For this tutorial we will use \nSandbox\n\n\ncd Sandbox\n\n\n\nNow use the \nlisa-api-cli\n to create the plugin from the template\n\n\nlisa-api-cli plugins --create\n\n\n\nNow, answer to the questions. For example, to create the shopping plugin :\n\n\nfull_name (default is \"Your full name here\")? Julien Syx\nemail (default is \"you@example.com\")? julien@lisa-project.net\ngithub_username (default is \"yourname\")? Seraf\napp_name (default is \"package\")? shopping\nproject_short_description (default is \"Your project description goes here\")? This plugin manage a shopping list\nyear (default is \"2015\")? \nversion (default is \"0.1.0\")? \nSuccessfully created the plugin\n\n\n\nLoad the plugin\n\n\nThe next step is to have your plugin loaded in the API (even if it do nothing).\n\n\nFirst, we will create a git repository to track the changes and share the sources to everyone.\nCreate a git repository on github, bitbucket, whatever you prefer, then initialize the repository :\n\n\ngit init\n\n\n\nAnd follow the instructions given by github to map this repository to the one you created :\n\n\ngit remote add origin git@github.com:Seraf/lisa-plugins-shopping.git\ngit add *\ngit commit . -m 'Initial commit'\ngit push -u origin master\n\n\n\nThe plugin will be packaged in the future but for development purpose, you will have to tell python where to load your package :\n\n\ncd Sandbox/lisa-plugins-shopping\npython setup.py sdist build\nexport PYTHONPATH=~/Sandbox/lisa-plugins-shopping:$PYTHONPATH\n\n\n\nI suggest to set this line in your rc file (depending your shell). Commonly it's \n~/.bashrc\n or \n.zshrc\n\n\nYou should see your package loaded by doing a \npip freeze | grep lisa-plugins\n\n\n-e git+https://github.com/project-lisa/lisa-plugins-shopping.git@bdfdd3a868926ed960f7be3ca27e77a03b88d920#egg=lisa_plugins_shopping-origin/develop\n\n\n\nCustomize the plugin\n\n\nFirst, you need to understand the concept of \nviews\n and \nmodels\n of Django.\n\n\nAdd a dependancie\n\n\nFor the shopping plugin, we want to have multiple lists. A list has a \nname\n and contains some products/items.\nAs items can be anything, it doesn't make sense to create a product model and play with foreign key to map a product on a list.\nInstead, I will use a jsonfield and create the list in a json. Later it will be easy to store a quantity of product directly in the json.\n\n\nTo add this jsonfield, we will need to use \ndjango-jsonfield\n.\n\n\nWhen you add a dependancie, you must know if this one is necessary for the plugin to work.\nIf it is needed, add it as a dependancie of your plugin, else you can include it in the \nrequirements-optional.txt\n file\n\n\nYou will need to update these files :\n\n\n\n\nrequirements/requirements-plugin.txt\n\n\nsetup.py\n\n\n\n\nThe setup file has already a dependancie to \nlisa-api\n. It seems logic, the plugin need the app where it will be run.\nWith this system you can also ask for a minimum version of the package.\nFor example you want to use a new class added in the version '1.3' of \nlisa-api\n, you can write \nlisa-api\n=1.3\n in the \nsetup.py\n requirements.\n\n\nWhen a user will download your plugin, it will ensure the user has the version 1.3 minimum or it will upgrade it to the latest version available.\n\n\nCreate a model\n\n\nAbove, we said that our list model will have a \nname\n attribute and a \nlist\n jsonfield :\n\n\nIn the \nlisa_plugins_shopping/models.py\n\n\nfrom django.db import models\nfrom jsonfield import JSONField\n\n\nclass ShoppingList(models.Model):\n    name = models.CharField(max_length=100, unique=True)\n    list = JSONField()\n\n    def save(self, force_insert=False, force_update=False, using=None,\n             update_fields=None):\n        self.name = self.name.lower()\n        super(ShoppingList, self).save(force_insert, force_update)\n\n\n\n\n\nThe function \nsave\n is here to override the default \nsave\n function of a model. Here, we want to have name always in lowercase.\n\n\nCreate a serializer\n\n\n\n\nSerializers allow complex data such as querysets and model instances to be converted to native Python datatypes that can then be easily rendered into JSON, XML or other content types.\nSerializers also provide deserialization, allowing parsed data to be converted back into complex types, after first validating the incoming data.\n-- \nDjango Rest Framework\n\n\n\n\nYou will find more informations on the \nserializers\n page of Django Rest Framework.\n\n\nIn our file \nlisa_plugins_shopping/serializers.py\n :\n\n\nfrom lisa_plugins_shopping.models import ShoppingList\nfrom rest_framework import serializers\n\n\nclass ShoppingListSerializer(serializers.HyperlinkedModelSerializer):\n    class Meta:\n        model = ShoppingList\n        fields = ('url', 'name', 'list')\n        extra_kwargs = {\n            'url': {'lookup_field': 'name'}\n        }\n\n\n\n\nThe \nextra_kwargs\n parameter allow us to build beautiful url replacing the id by the name of the list.\n\n\nCreate the view\n\n\n\n\nA view is a callable which takes a request and returns a response.\nThis can be more than just a function, and Django provides an example of some classes which can be used as views.\nThese allow you to structure your views and reuse code by harnessing inheritance and mixins.\n-- \nDjango\n\n\n\n\nThe view will contains all the logic to apply. It receive a request, apply some operations and return a response.\n\n\nAs we have a simple model, we don't want to write all the create/read/update/delete views, so we use Django Rest Framework which automate all these things using a \nviewset\n.\n\n\nIn our file \nlisa_plugins_shopping/views.py\n :\n\n\nfrom lisa_plugins_shopping.models import ShoppingList\nfrom lisa_plugins_shopping.serializers import ShoppingListSerializer\n\n\nclass ShoppingListViewSet(viewsets.ModelViewSet):\n    \n\n    API endpoint that allows users to add/edit/delete shopping lists.\n    \n\n    queryset = ShoppingList.objects.all()\n    serializer_class = ShoppingListSerializer\n    lookup_field = 'name'\n\n\n\n\nThe viewset will handle \nauto-magically\n the views for your object.\n\n\nCreate the url\n\n\nThe view is created, now you need to tell django how to redirect the request to the correct view.\n\n\nIn the file \nlisa_plugins_shopping/urls.py\n :\n\n\nfrom lisa_plugins_shopping.views import ShoppingListViewSet\nfrom rest_framework import routers\nfrom django.conf.urls import include, url\n\nrouter = routers.DefaultRouter()\nrouter.register(r'lists', ShoppingListViewSet)\n\nurlpatterns = [\n    url(r'^/', include(router.urls)),\n]\n\n\n\n\nWe bind the url \n/lists\n to the view we created above.\n\n\nApply your model to SQL\n\n\nYou now have you model, but you need to create the tables in your database.\nDon't worry, Django will manage them for you. In the last release, it come with a native tool to handle the schema management.\n\n\nEach time you will do a modification on your models, you will need to create a migration file :\n\n\nlisa-api-cli makemigrations\n\n\n\n\nIt will create in each app loaded, the migration files under the directory \nmigrations\n.\n\n\nNow, to apply these migrations :\n\n\nlisa-api-cli migrate\n\n\n\n\nAccess the url\n\n\nNow, you can run the lisa-api server :\n\n\nlisa-api-cli runserver 0.0.0.0:8000\n\n\n\n\nThen, go on \nhttp://localhost:8000/docs/\n (be sure to be \nlogged\n before)\n\n\nYou should see your plugin and the methods available.\n\n\nThe LISA API will automatically provide an url like this : http://server/api/v1/plugin-\nplugin-name\n/\n\n\nFor example, to create a list :\n\n\ncurl -X POST -H \nContent-Type: application/json\n http://localhost:8000/api/v1/plugin-shopping/lists/ --data '{\nname\n: \ntest-list\n, \nitems\n: []}'\n\n\n\n\nHow to add a custom route\n\n\nIf creating a model and his views is very easy, you may need to create custom views.\n\n\nFor example, we want to add a route to add or delete some products on our list.\n\n\nCreate the serializer :\n\n\nclass ItemSerializer(serializers.Serializer):\n    items = serializers.ListField(child=serializers.CharField())\n\n\n\n\nWe want to receive a list of string like ['tomatoes', 'cucumbers', 'potatoes']\n\n\nNow, let's create the view (adding the item_add to existing view) :\n\n\nfrom lisa_plugins_shopping.models import ShoppingList\nfrom rest_framework import viewsets, status\nfrom rest_framework.response import Response\nfrom lisa_plugins_shopping.serializers import ShoppingListSerializer, ItemSerializer\nfrom rest_framework.decorators import detail_route\nfrom lisa_api.lisa.logger import logger\nfrom django.utils.translation import ugettext as _\n\n\nclass ShoppingListViewSet(viewsets.ModelViewSet):\n    \n\n    API endpoint that allows users to add/edit/delete shopping lists.\n    \n\n    queryset = ShoppingList.objects.all()\n    serializer_class = ShoppingListSerializer\n    lookup_field = 'name'\n\n    @detail_route(methods=['POST'], serializer_class=ItemSerializer)\n    def item_add(self, request, name=None):\n        \n\n        This function manage the jsonfield of a shopping list by adding a product\n        :param request:\n        :param name:\n        :return:\n\n        Example (if the shopping list name is 'default'):\n        curl -X POST -H \nContent-Type: application/json\n http://127.0.0.1:8000/api/v1/plugin-shopping/lists/default/item_add/ --data '{\nitems\n: [\ncarotte\n, \nchocolat\n]}\n        ---\n        request_serializer: ItemSerializer\n        response_serializer: ItemSerializer\n        \n\n        list = self.get_object()\n        json_list = list.list\n\n        if not json_list.get('items'):\n            json_list = {'items': []}\n\n        if request.method == 'POST':\n            serializer = ItemSerializer(data=request.data)\n            if serializer.is_valid():\n                logger.debug(serializer.data['items'])\n                for item in serializer.data['items']:\n                    if item not in json_list['items']:\n                        json_list['items'].append(item)\n                        logger.debug('Adding item {item} to the list'.format(item=item))\n                    else:\n                        logger.debug('Item {item} already exist'.format(item=item))\n                list.list = json_list\n                list.save()\n                return Response(_('Item {items} has been added to the list').format(\n                    items=', '.join(serializer.data['items'])), status=status.HTTP_201_CREATED)\n            else:\n                return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n\n\n\n\nWe declare a custom route named \nitem_add\n and it will be available on \n/api/v1/plugin-shopping/lists/{list_name}/item_add/\n.\n\n\nIt's a good practice to add some documentation about your routes, what they done, how to call them etc.\n\n\nYou can test to add a function to retrieve the list items, and to delete items.\n\n\nThe complete sources are [available on github][github-shopping-plugin].\n\n\nAdd an intent\n\n\nThe first goal of LISA is to provide an API to connect everything. With the steps above we have enough knowledge to create all plugins we want.\n\n\nBut as you may know the second goal of LISA is to let a human interact direcly with this API, by voice or text.\n\n\nIt means we need to convert a sentence into a HTTP request. It's difficult to know from a sentence to another which field to fill or not.\n\n\nFor that, in the \n__init__.py\n file of your plugin, you will have a function named \nadd_intents\n\n\nWhen the server start, it will load each plugin and execute this function.\nThis function add in a table the name of the intent and the url to call.\n\n\nLet's start adding an intent :\n\n\nobj, created = Intent.objects.update_or_create(\n    name='shopping_item_add',\n    defaults={\n        'method': 'POST',\n        'api_url': '/api/v1/plugin-shopping/lists/{list_name}/item_add/'\n    }\n)\nlogger.debug(\nAdding {intent_name} intent for shopping plugin\n.format(intent_name=obj.name))\n\n\n\n\n\nIt will add an intent named \nshopping_item_add\n if it didn't already exist or update this one.\n\n\nThis intent use the \nPOST\n http verb on the url \n/api/v1/plugin-shopping/lists/{list_name}/item_add/\n\n\nThe \n{}\n allow to specify dynamic fields of the url. If the sentence is \n\"add some potatoes on the list wallmart\"\n, it will replace \n{listname}\n by \nwallmart\n\n\nThe client will process the sentence with a NLP application and will ask the intent metadata to LISA API.\n\n\nLISA API will answer with these info, so the client will know the url of your function. One thing it doesn't know yet is how to deal with the arguments.\n\n\nIt will query the url (your view) with \nOPTIONS\n verb. It will answer with arguments available :\n\n\ncurl -X OPTIONS -H \nContent-Type: application/json\n http://127.0.0.1:8000/api/v1/plugin-shopping/lists/wallmart/item_add\n\n\n\n\n{  \n   \nname\n:\nShopping List\n,\n   \ndescription\n:\nAPI endpoint that allows users to add/edit/delete shopping lists.\n,\n   \nrenders\n:[  \n      \napplication/json\n,\n      \ntext/html\n\n   ],\n   \nparses\n:[  \n      \napplication/json\n,\n      \napplication/x-www-form-urlencoded\n,\n      \nmultipart/form-data\n\n   ],\n   \nactions\n:{  \n      \nPOST\n:{  \n         \nitems\n:{  \n            \ntype\n:\nlist\n,\n            \nrequired\n:true,\n            \nread_only\n:false,\n            \nlabel\n:\nItems\n,\n            \nchild\n:{  \n               \ntype\n:\nstring\n,\n               \nrequired\n:true,\n               \nread_only\n:false\n            }\n         }\n      }\n   }\n}\n\n\n\n\nAnd now, the client will map the field items of your sentence to the items argument.\nAs the view need a \nPOST\n query, the client will do a \nPOST\n on the url it already knows, with the args filled.\n\n\nPublish it\n\n\nTo publish your plugin, you need to be sure to have a \npypi\n account and \nregister\n your plugin, then :\n\n\ncd Sandbox/lisa-plugins-shopping\npython setup.py publish\n\n\n\nThe command \npublish\n has been added in your \nsetup.py\n file \n\n\nWrite more complex plugins\n\n\nYou can do whatever you want. You only need to follow the structure of the plugin, but the content of the views is up to you.\n\n\nAs plugins are based on the \nDjango Rest Framework\n, you should read their documentation to know how to achieve your goal.", 
            "title": "Plugins"
        }, 
        {
            "location": "/tutorial/1-plugins/#plugins", 
            "text": "", 
            "title": "Plugins"
        }, 
        {
            "location": "/tutorial/1-plugins/#how-it-work", 
            "text": "As the API is done with  Django , you will need to understand  Django  to create the plugins.  Plugins are created with  Django Rest Framework  (you should read the docs too).  Each plugin is a  Django Application  which is dynamically loaded by django using the entry points.  An entry point is a Python object in a project\u2019s code that is identified by a string in the project\u2019s  setup.py  file. The entry point is referenced by a group and a name so that the object may be discoverable. This means that another application can search for all the installed software that has an entry point with a particular group name, and then access the Python object associated with that name.  This is extremely useful because it means it is possible to write plugins for an appropriately-designed application that can be loaded at run time.  It is important to understand that entry points are a feature of the new Python eggs package format and are not a standard feature of Python.  The entry point in our plugin look like :  entry_points={\n    'lisa.api.plugins': [\n        'shopping = lisa_plugins_shopping:ShoppingPlugin',\n    ]\n},  We register the plugin  shopping  in the namespace  lisa.api.plugins  and it is mapped to the class  ShoppingPlugin  in our package (defined in the  __init__.py  file).  The  INSTALLED_APP  list of Django is populated by the plugin manager which will look for all plugin available in the namespace  lisa.api.plugins  and will import all their urls and models.  Django as other framework don't support to add or delete routes at runtime. So the plugins are loaded when the api server is launched.\nWhen a new plugin is installed or removed, the server needs to be restarted. It has been automated by changing the file attribute of  __init__.py  so the django server do a reload.", 
            "title": "How it work"
        }, 
        {
            "location": "/tutorial/1-plugins/#structure", 
            "text": "A plugin is mainly a Django Application with some added features. By default, it has this structure :   tests  : it's the directory containing all your unit tests to be sure your plugin will work even if you modify it, or if it works with the new LISA API versions  requirements/requirements-plugin.txt  : this file contains the libraries required for your plugin (note that it differs from pip dependancies (check the setup.py file)  setup.py  : this file manage how you're plugin will be installed. You configure your name, and few metadata that will appears on pypi. You will have to edit this file to add entry_points or to add required libraries  lisa_plugins_shopping/__init__.py  : contains metadata about your plugin and the intents mapped to your API.  lisa_plugins_shopping/models.py  : contains the model of your object (optional). This model will be the table in the database you could use  lisa_plugins_shopping/serializers.py  : contains classes to explain to django how to serialize the data received on the API  lisa_plugins_shopping/urls.py  : contains url and the view attached  lisa_plugins_shopping/views.py  : the most important part of your plugin. It contains all the logic and how the data received should be used  lisa_plugins_shopping/migrations  : this directory contains all the evolutions of your model. his directory is automatically managed by django and will provide a very easy system to distribute new version of your plugin", 
            "title": "Structure"
        }, 
        {
            "location": "/tutorial/1-plugins/#install-a-plugin", 
            "text": "The goal is to create a community around LISA. Users will create plugins and share them to others.  Installing a plugin is very simple. You just need to do a HTTP query on the API :  curl -X POST -H  Content-Type: application/json  http://localhost:8000/api/v1/core/plugins/ --data '{ name :  shopping }'", 
            "title": "Install a plugin"
        }, 
        {
            "location": "/tutorial/1-plugins/#create-your-first-plugin", 
            "text": "Place yourself in the directory where you have permissions to create a directory and would like to work. For this tutorial we will use  Sandbox  cd Sandbox  Now use the  lisa-api-cli  to create the plugin from the template  lisa-api-cli plugins --create  Now, answer to the questions. For example, to create the shopping plugin :  full_name (default is \"Your full name here\")? Julien Syx\nemail (default is \"you@example.com\")? julien@lisa-project.net\ngithub_username (default is \"yourname\")? Seraf\napp_name (default is \"package\")? shopping\nproject_short_description (default is \"Your project description goes here\")? This plugin manage a shopping list\nyear (default is \"2015\")? \nversion (default is \"0.1.0\")? \nSuccessfully created the plugin  Load the plugin  The next step is to have your plugin loaded in the API (even if it do nothing).  First, we will create a git repository to track the changes and share the sources to everyone.\nCreate a git repository on github, bitbucket, whatever you prefer, then initialize the repository :  git init  And follow the instructions given by github to map this repository to the one you created :  git remote add origin git@github.com:Seraf/lisa-plugins-shopping.git\ngit add *\ngit commit . -m 'Initial commit'\ngit push -u origin master  The plugin will be packaged in the future but for development purpose, you will have to tell python where to load your package :  cd Sandbox/lisa-plugins-shopping\npython setup.py sdist build\nexport PYTHONPATH=~/Sandbox/lisa-plugins-shopping:$PYTHONPATH  I suggest to set this line in your rc file (depending your shell). Commonly it's  ~/.bashrc  or  .zshrc  You should see your package loaded by doing a  pip freeze | grep lisa-plugins  -e git+https://github.com/project-lisa/lisa-plugins-shopping.git@bdfdd3a868926ed960f7be3ca27e77a03b88d920#egg=lisa_plugins_shopping-origin/develop  Customize the plugin  First, you need to understand the concept of  views  and  models  of Django.  Add a dependancie  For the shopping plugin, we want to have multiple lists. A list has a  name  and contains some products/items.\nAs items can be anything, it doesn't make sense to create a product model and play with foreign key to map a product on a list.\nInstead, I will use a jsonfield and create the list in a json. Later it will be easy to store a quantity of product directly in the json.  To add this jsonfield, we will need to use  django-jsonfield .  When you add a dependancie, you must know if this one is necessary for the plugin to work.\nIf it is needed, add it as a dependancie of your plugin, else you can include it in the  requirements-optional.txt  file  You will need to update these files :   requirements/requirements-plugin.txt  setup.py   The setup file has already a dependancie to  lisa-api . It seems logic, the plugin need the app where it will be run.\nWith this system you can also ask for a minimum version of the package.\nFor example you want to use a new class added in the version '1.3' of  lisa-api , you can write  lisa-api =1.3  in the  setup.py  requirements.  When a user will download your plugin, it will ensure the user has the version 1.3 minimum or it will upgrade it to the latest version available.  Create a model  Above, we said that our list model will have a  name  attribute and a  list  jsonfield :  In the  lisa_plugins_shopping/models.py  from django.db import models\nfrom jsonfield import JSONField\n\n\nclass ShoppingList(models.Model):\n    name = models.CharField(max_length=100, unique=True)\n    list = JSONField()\n\n    def save(self, force_insert=False, force_update=False, using=None,\n             update_fields=None):\n        self.name = self.name.lower()\n        super(ShoppingList, self).save(force_insert, force_update)  The function  save  is here to override the default  save  function of a model. Here, we want to have name always in lowercase.  Create a serializer   Serializers allow complex data such as querysets and model instances to be converted to native Python datatypes that can then be easily rendered into JSON, XML or other content types.\nSerializers also provide deserialization, allowing parsed data to be converted back into complex types, after first validating the incoming data.\n--  Django Rest Framework   You will find more informations on the  serializers  page of Django Rest Framework.  In our file  lisa_plugins_shopping/serializers.py  :  from lisa_plugins_shopping.models import ShoppingList\nfrom rest_framework import serializers\n\n\nclass ShoppingListSerializer(serializers.HyperlinkedModelSerializer):\n    class Meta:\n        model = ShoppingList\n        fields = ('url', 'name', 'list')\n        extra_kwargs = {\n            'url': {'lookup_field': 'name'}\n        }  The  extra_kwargs  parameter allow us to build beautiful url replacing the id by the name of the list.  Create the view   A view is a callable which takes a request and returns a response.\nThis can be more than just a function, and Django provides an example of some classes which can be used as views.\nThese allow you to structure your views and reuse code by harnessing inheritance and mixins.\n--  Django   The view will contains all the logic to apply. It receive a request, apply some operations and return a response.  As we have a simple model, we don't want to write all the create/read/update/delete views, so we use Django Rest Framework which automate all these things using a  viewset .  In our file  lisa_plugins_shopping/views.py  :  from lisa_plugins_shopping.models import ShoppingList\nfrom lisa_plugins_shopping.serializers import ShoppingListSerializer\n\n\nclass ShoppingListViewSet(viewsets.ModelViewSet):\n     \n    API endpoint that allows users to add/edit/delete shopping lists.\n     \n    queryset = ShoppingList.objects.all()\n    serializer_class = ShoppingListSerializer\n    lookup_field = 'name'  The viewset will handle  auto-magically  the views for your object.  Create the url  The view is created, now you need to tell django how to redirect the request to the correct view.  In the file  lisa_plugins_shopping/urls.py  :  from lisa_plugins_shopping.views import ShoppingListViewSet\nfrom rest_framework import routers\nfrom django.conf.urls import include, url\n\nrouter = routers.DefaultRouter()\nrouter.register(r'lists', ShoppingListViewSet)\n\nurlpatterns = [\n    url(r'^/', include(router.urls)),\n]  We bind the url  /lists  to the view we created above.  Apply your model to SQL  You now have you model, but you need to create the tables in your database.\nDon't worry, Django will manage them for you. In the last release, it come with a native tool to handle the schema management.  Each time you will do a modification on your models, you will need to create a migration file :  lisa-api-cli makemigrations  It will create in each app loaded, the migration files under the directory  migrations .  Now, to apply these migrations :  lisa-api-cli migrate  Access the url  Now, you can run the lisa-api server :  lisa-api-cli runserver 0.0.0.0:8000  Then, go on  http://localhost:8000/docs/  (be sure to be  logged  before)  You should see your plugin and the methods available.  The LISA API will automatically provide an url like this : http://server/api/v1/plugin- plugin-name /  For example, to create a list :  curl -X POST -H  Content-Type: application/json  http://localhost:8000/api/v1/plugin-shopping/lists/ --data '{ name :  test-list ,  items : []}'  How to add a custom route  If creating a model and his views is very easy, you may need to create custom views.  For example, we want to add a route to add or delete some products on our list.  Create the serializer :  class ItemSerializer(serializers.Serializer):\n    items = serializers.ListField(child=serializers.CharField())  We want to receive a list of string like ['tomatoes', 'cucumbers', 'potatoes']  Now, let's create the view (adding the item_add to existing view) :  from lisa_plugins_shopping.models import ShoppingList\nfrom rest_framework import viewsets, status\nfrom rest_framework.response import Response\nfrom lisa_plugins_shopping.serializers import ShoppingListSerializer, ItemSerializer\nfrom rest_framework.decorators import detail_route\nfrom lisa_api.lisa.logger import logger\nfrom django.utils.translation import ugettext as _\n\n\nclass ShoppingListViewSet(viewsets.ModelViewSet):\n     \n    API endpoint that allows users to add/edit/delete shopping lists.\n     \n    queryset = ShoppingList.objects.all()\n    serializer_class = ShoppingListSerializer\n    lookup_field = 'name'\n\n    @detail_route(methods=['POST'], serializer_class=ItemSerializer)\n    def item_add(self, request, name=None):\n         \n        This function manage the jsonfield of a shopping list by adding a product\n        :param request:\n        :param name:\n        :return:\n\n        Example (if the shopping list name is 'default'):\n        curl -X POST -H  Content-Type: application/json  http://127.0.0.1:8000/api/v1/plugin-shopping/lists/default/item_add/ --data '{ items : [ carotte ,  chocolat ]}\n        ---\n        request_serializer: ItemSerializer\n        response_serializer: ItemSerializer\n         \n        list = self.get_object()\n        json_list = list.list\n\n        if not json_list.get('items'):\n            json_list = {'items': []}\n\n        if request.method == 'POST':\n            serializer = ItemSerializer(data=request.data)\n            if serializer.is_valid():\n                logger.debug(serializer.data['items'])\n                for item in serializer.data['items']:\n                    if item not in json_list['items']:\n                        json_list['items'].append(item)\n                        logger.debug('Adding item {item} to the list'.format(item=item))\n                    else:\n                        logger.debug('Item {item} already exist'.format(item=item))\n                list.list = json_list\n                list.save()\n                return Response(_('Item {items} has been added to the list').format(\n                    items=', '.join(serializer.data['items'])), status=status.HTTP_201_CREATED)\n            else:\n                return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)  We declare a custom route named  item_add  and it will be available on  /api/v1/plugin-shopping/lists/{list_name}/item_add/ .  It's a good practice to add some documentation about your routes, what they done, how to call them etc.  You can test to add a function to retrieve the list items, and to delete items.  The complete sources are [available on github][github-shopping-plugin].  Add an intent  The first goal of LISA is to provide an API to connect everything. With the steps above we have enough knowledge to create all plugins we want.  But as you may know the second goal of LISA is to let a human interact direcly with this API, by voice or text.  It means we need to convert a sentence into a HTTP request. It's difficult to know from a sentence to another which field to fill or not.  For that, in the  __init__.py  file of your plugin, you will have a function named  add_intents  When the server start, it will load each plugin and execute this function.\nThis function add in a table the name of the intent and the url to call.  Let's start adding an intent :  obj, created = Intent.objects.update_or_create(\n    name='shopping_item_add',\n    defaults={\n        'method': 'POST',\n        'api_url': '/api/v1/plugin-shopping/lists/{list_name}/item_add/'\n    }\n)\nlogger.debug( Adding {intent_name} intent for shopping plugin .format(intent_name=obj.name))  It will add an intent named  shopping_item_add  if it didn't already exist or update this one.  This intent use the  POST  http verb on the url  /api/v1/plugin-shopping/lists/{list_name}/item_add/  The  {}  allow to specify dynamic fields of the url. If the sentence is  \"add some potatoes on the list wallmart\" , it will replace  {listname}  by  wallmart  The client will process the sentence with a NLP application and will ask the intent metadata to LISA API.  LISA API will answer with these info, so the client will know the url of your function. One thing it doesn't know yet is how to deal with the arguments.  It will query the url (your view) with  OPTIONS  verb. It will answer with arguments available :  curl -X OPTIONS -H  Content-Type: application/json  http://127.0.0.1:8000/api/v1/plugin-shopping/lists/wallmart/item_add  {  \n    name : Shopping List ,\n    description : API endpoint that allows users to add/edit/delete shopping lists. ,\n    renders :[  \n       application/json ,\n       text/html \n   ],\n    parses :[  \n       application/json ,\n       application/x-www-form-urlencoded ,\n       multipart/form-data \n   ],\n    actions :{  \n       POST :{  \n          items :{  \n             type : list ,\n             required :true,\n             read_only :false,\n             label : Items ,\n             child :{  \n                type : string ,\n                required :true,\n                read_only :false\n            }\n         }\n      }\n   }\n}  And now, the client will map the field items of your sentence to the items argument.\nAs the view need a  POST  query, the client will do a  POST  on the url it already knows, with the args filled.  Publish it  To publish your plugin, you need to be sure to have a  pypi  account and  register  your plugin, then :  cd Sandbox/lisa-plugins-shopping\npython setup.py publish  The command  publish  has been added in your  setup.py  file   Write more complex plugins  You can do whatever you want. You only need to follow the structure of the plugin, but the content of the views is up to you.  As plugins are based on the  Django Rest Framework , you should read their documentation to know how to achieve your goal.", 
            "title": "Create your first plugin"
        }, 
        {
            "location": "/topics/internationalization/", 
            "text": "Internationalization\n\n\nLISA ships with translatable error messages.\n\n\n\n\nSelect a language other than English as the default, using the \nlang_django\n setting in configuration file.\n\n\nAllow clients to choose a language themselves. A typical usage for API clients would be to include an \nAccept-Language\n request header.\n\n\n\n\nEnabling internationalized APIs\n\n\nYou can change the default language by using the \nlang_django\n setting in LISA API configuration file:\n\n\nlang_django = \"es-es\"\n\n\n\nBy default, the per-request language requests is enabled, so client requests will respect the \nAccept-Language\n header where possible. For example, let's make a request for an unsupported media type:\n\n\nRequest\n\n\nGET /api/users HTTP/1.1\nAccept: application/xml\nAccept-Language: es-es\nHost: example.org\n\n\n\nResponse\n\n\nHTTP/1.0 406 NOT ACCEPTABLE\n\n{\"detail\": \"No se ha podido satisfacer la solicitud de cabecera de Accept.\"}\n\n\n\nLISA includes these built-in translations both for standard exception cases, and for serializer validation errors.\n\n\nNote that the translations only apply to the error strings themselves. The format of error messages, and the keys of field names will remain the same. An example \n400 Bad Request\n response body might look like this:\n\n\n{\"detail\": {\"username\": [\"Esse campo deve ser unico.\"]}}\n\n\n\nAdding new translations\n\n\nLISA translations are managed online using \nTransifex\n. You can use the Transifex service to add new translation languages. The maintenance team will then ensure that these translation strings are included in the LISA package.\n\n\nTranslating a new language locally\n\n\nThis guide assumes you are already familiar with how to translate a Django app.  If you're not, start by reading \nDjango's translation docs\n.\n\n\nIf you're translating a new language you'll need to translate the existing LISA error messages:\n\n\n\n\n\n\nMake a new folder where you want to store the internationalization resources. Add this path to your \nLOCALE_PATHS\n setting.\n\n\n\n\n\n\nNow create a subfolder for the language you want to translate. The folder should be named using \nlocale name\n notation. For example: \nde\n, \npt_BR\n, \nes_AR\n.\n\n\n\n\n\n\nNow copy the \nbase translations file\n from the LISA source code into your translations folder.\n\n\n\n\n\n\nEdit the \nlisa_api.po\n file you've just copied, translating all the error messages.\n\n\n\n\n\n\nRun \nlisa-api-cli compilemessages -l pt_BR\n to make the translations \navailable for Django to use. You should see a message like \nprocessing file lisa_api.po in \n...\n/locale/pt_BR/LC_MESSAGES\n.\n\n\n\n\n\n\nRestart your development server to see the changes take effect.\n\n\n\n\n\n\nIf you're only translating custom error messages that exist inside your project codebase you don't need to copy the LISA source \nlisa_api.po\n file into a \nLOCALE_PATHS\n folder, and can instead simply run Django's standard \nmakemessages\n process.\n\n\nHow the language is determined\n\n\nYou can find more information on how the language preference is determined in the \nDjango documentation\n. For reference, the method is:\n\n\n\n\nFirst, it looks for the language prefix in the requested URL.\n\n\nFailing that, it looks for the \nLANGUAGE_SESSION_KEY\n key in the current user\u2019s session.\n\n\nFailing that, it looks for a cookie.\n\n\nFailing that, it looks at the \nAccept-Language\n HTTP header.\n\n\nFailing that, it uses the global \nLANGUAGE_CODE\n setting which is defined in the LISA configuration file with the \nlang_django\n setting.\n\n\n\n\nFor API clients the most appropriate of these will typically be to use the \nAccept-Language\n header; Sessions and cookies will not be available unless using session authentication, and generally better practice to prefer an \nAccept-Language\n header for API clients rather than using language URL prefixes.", 
            "title": "Internationalization"
        }, 
        {
            "location": "/topics/internationalization/#internationalization", 
            "text": "LISA ships with translatable error messages.   Select a language other than English as the default, using the  lang_django  setting in configuration file.  Allow clients to choose a language themselves. A typical usage for API clients would be to include an  Accept-Language  request header.", 
            "title": "Internationalization"
        }, 
        {
            "location": "/topics/internationalization/#enabling-internationalized-apis", 
            "text": "You can change the default language by using the  lang_django  setting in LISA API configuration file:  lang_django = \"es-es\"  By default, the per-request language requests is enabled, so client requests will respect the  Accept-Language  header where possible. For example, let's make a request for an unsupported media type:  Request  GET /api/users HTTP/1.1\nAccept: application/xml\nAccept-Language: es-es\nHost: example.org  Response  HTTP/1.0 406 NOT ACCEPTABLE\n\n{\"detail\": \"No se ha podido satisfacer la solicitud de cabecera de Accept.\"}  LISA includes these built-in translations both for standard exception cases, and for serializer validation errors.  Note that the translations only apply to the error strings themselves. The format of error messages, and the keys of field names will remain the same. An example  400 Bad Request  response body might look like this:  {\"detail\": {\"username\": [\"Esse campo deve ser unico.\"]}}", 
            "title": "Enabling internationalized APIs"
        }, 
        {
            "location": "/topics/internationalization/#adding-new-translations", 
            "text": "LISA translations are managed online using  Transifex . You can use the Transifex service to add new translation languages. The maintenance team will then ensure that these translation strings are included in the LISA package.  Translating a new language locally  This guide assumes you are already familiar with how to translate a Django app.  If you're not, start by reading  Django's translation docs .  If you're translating a new language you'll need to translate the existing LISA error messages:    Make a new folder where you want to store the internationalization resources. Add this path to your  LOCALE_PATHS  setting.    Now create a subfolder for the language you want to translate. The folder should be named using  locale name  notation. For example:  de ,  pt_BR ,  es_AR .    Now copy the  base translations file  from the LISA source code into your translations folder.    Edit the  lisa_api.po  file you've just copied, translating all the error messages.    Run  lisa-api-cli compilemessages -l pt_BR  to make the translations \navailable for Django to use. You should see a message like  processing file lisa_api.po in  ... /locale/pt_BR/LC_MESSAGES .    Restart your development server to see the changes take effect.    If you're only translating custom error messages that exist inside your project codebase you don't need to copy the LISA source  lisa_api.po  file into a  LOCALE_PATHS  folder, and can instead simply run Django's standard  makemessages  process.", 
            "title": "Adding new translations"
        }, 
        {
            "location": "/topics/internationalization/#how-the-language-is-determined", 
            "text": "You can find more information on how the language preference is determined in the  Django documentation . For reference, the method is:   First, it looks for the language prefix in the requested URL.  Failing that, it looks for the  LANGUAGE_SESSION_KEY  key in the current user\u2019s session.  Failing that, it looks for a cookie.  Failing that, it looks at the  Accept-Language  HTTP header.  Failing that, it uses the global  LANGUAGE_CODE  setting which is defined in the LISA configuration file with the  lang_django  setting.   For API clients the most appropriate of these will typically be to use the  Accept-Language  header; Sessions and cookies will not be available unless using session authentication, and generally better practice to prefer an  Accept-Language  header for API clients rather than using language URL prefixes.", 
            "title": "How the language is determined"
        }, 
        {
            "location": "/topics/contributing/", 
            "text": "Contributing to LISA\n\n\nThere are many ways you can contribute to LISA API.  We'd like it to be a community-led project, so please get involved and help shape the future of the project.\n\n\nCommunity\n\n\nThe most important thing you can do to help push the project forward is to be actively involved wherever possible.  Code contributions are often overvalued as being the primary way to get involved in a project, we don't believe that needs to be the case.\n\n\nIf you use LISA, we'd love you to be vocal about your experiences with it - you might consider writing a blog post about using LISA, or publishing a tutorial about your home automation with LISA.  Experiences from beginners can be particularly helpful because you'll be in the best position to assess which bits of LISA are more difficult to understand and work with.\n\n\nCode of conduct\n\n\nPlease keep the tone polite \n professional.  First impressions count, so let's try to make everyone feel welcome.\n\n\nBe mindful in the language you choose.  As an example, in an environment that is heavily male-dominated, posts that start 'Hey guys,' can come across as unintentionally exclusive.  It's just as easy, and more inclusive to use gender neutral language in those situations.\n\n\nIssues\n\n\nIt's really helpful if you can make sure to address issues on the correct channel.  Usage questions should be directed to the \nGitter\n.  Feature requests, bug reports and other issues should be raised on the GitHub \nissue tracker\n.\n\n\nSome tips on good issue reporting:\n\n\n\n\nWhen describing issues try to phrase your ticket in terms of the \nbehavior\n you think needs changing rather than the \ncode\n you think need changing.\n\n\nSearch the issue list first for related items, and make sure you're running the latest version of LISA before reporting an issue.\n\n\nIf reporting a bug, then try to include a pull request with a failing test case.  This will help us quickly identify if there is a valid issue, and make sure that it gets fixed more quickly if there is one.\n\n\nFeature requests will often be closed with a recommendation that they be implemented outside of the core.  Keeping new feature requests implemented as third party libraries allows us to keep down the maintenance overhead of the project, so that the focus can be on continued stability, bugfixes, and great documentation.\n\n\nClosing an issue doesn't necessarily mean the end of a discussion.  If you believe your issue has been closed incorrectly, explain why and we'll consider if it needs to be reopened.\n\n\n\n\nTriaging issues\n\n\nGetting involved in triaging incoming issues is a good way to start contributing.  Every single ticket that comes into the ticket tracker needs to be reviewed in order to determine what the next steps should be.  Anyone can help out with this, you just need to be willing to\n\n\n\n\nRead through the ticket - does it make sense, is it missing any context that would help explain it better?\n\n\nIs the ticket reported in the correct place, would it be better suited as a discussion on gitter?\n\n\nIf the ticket is a bug report, can you reproduce it? Are you able to write a failing test case that demonstrates the issue and that can be submitted as a pull request?\n\n\nIf the ticket is a feature request, do you agree with it, and could the feature request instead be implemented as a third party package?\n\n\nIf a ticket hasn't had much activity and it addresses something you need, then comment on the ticket and try to find out what's needed to get it moving again.\n\n\n\n\nDevelopment\n\n\nTo start developing on LISA API, clone the repo:\n\n\ngit clone git@github.com:project-lisa/lisa-api.git\n\n\n\nChanges should broadly follow the \nPEP 8\n style conventions, and we recommend you set up your editor to automatically indicate non-conforming styles.\n\n\nTesting\n\n\nTo run the tests, clone the repository, and then:\n\n\n# Setup the virtual environment\nvirtualenv env\nsource env/bin/activate\npip install -r requirements.txt\n\n# Run the tests\n./runtests.py\n\n\n\nTest options\n\n\nRun using a more concise output style.\n\n\n./runtests.py -q\n\n\n\nRun the tests using a more concise output style, no coverage, no flake8.\n\n\n./runtests.py --fast\n\n\n\nDon't run the flake8 code linting.\n\n\n./runtests.py --nolint\n\n\n\nOnly run the flake8 code linting, don't run the tests.\n\n\n./runtests.py --lintonly\n\n\n\nRun the tests for a given test case.\n\n\n./runtests.py MyTestCase\n\n\n\nRun the tests for a given test method.\n\n\n./runtests.py MyTestCase.test_this_method\n\n\n\nShorter form to run the tests for a given test method.\n\n\n./runtests.py test_this_method\n\n\n\nNote: The test case and test method matching is fuzzy and will sometimes run other tests that contain a partial string match to the given  command line input.\n\n\nRunning against multiple environments\n\n\nYou can also use the excellent \ntox\n testing tool to run the tests against all supported versions of Python and Django.  Install \ntox\n globally, and then simply run:\n\n\ntox\n\n\n\nPull requests\n\n\nIt's a good idea to make pull requests early on.  A pull request represents the start of a discussion, and doesn't necessarily need to be the final, finished submission.\n\n\nIt's also always best to make a new branch before starting work on a pull request.  This means that you'll be able to later switch back to working on another separate issue without interfering with an ongoing pull requests.\n\n\nIt's also useful to remember that if you have an outstanding pull request then pushing new commits to your GitHub repo will also automatically update the pull requests.\n\n\nGitHub's documentation for working on pull requests is \navailable here\n.\n\n\nAlways run the tests before submitting pull requests, and ideally run \ntox\n in order to check that your modifications are compatible with both Python 2 and Python 3, and that they run properly on all supported versions of Django.\n\n\nOnce you've made a pull request take a look at the Travis build status in the GitHub interface and make sure the tests are running as you'd expect.\n\n\n\n\nAbove: Travis build notifications\n\n\nManaging compatibility issues\n\n\nSometimes, in order to ensure your code works on various different versions of Django, Python or third party libraries, you'll need to run slightly different code depending on the environment.  Any code that branches in this way should be isolated into the \ncompat.py\n module, and should provide a single common interface that the rest of the codebase can use.\n\n\nDocumentation\n\n\nThe documentation for LISA API is built from the \nMarkdown\n source files in \nthe docs directory\n.\n\n\nThere are many great Markdown editors that make working with the documentation really easy.\n\n\nBuilding the documentation\n\n\nTo build the documentation, install MkDocs with \npip install mkdocs\n and then run the following command.\n\n\nmkdocs build\n\n\n\nThis will build the documentation into the \nsite\n directory.\n\n\nYou can build the documentation and open a preview in a browser window by using the \nserve\n command.\n\n\nmkdocs serve\n\n\n\nLanguage style\n\n\nDocumentation should be in American English.  The tone of the documentation is very important - try to stick to a simple, plain, objective and well-balanced style where possible.\n\n\nSome other tips:\n\n\n\n\nKeep paragraphs reasonably short.\n\n\nDon't use abbreviations such as 'e.g.' but instead use the long form, such as 'For example'.\n\n\n\n\nMarkdown style\n\n\nThere are a couple of conventions you should follow when working on the documentation.\n\n\n1. Headers\n\n\nHeaders should use the hash style.  For example:\n\n\n### Some important topic\n\n\n\nThe underline style should not be used.  \nDon't do this:\n\n\nSome important topic\n====================\n\n\n\n2. Links\n\n\nLinks should always use the reference style, with the referenced hyperlinks kept at the end of the document.\n\n\nHere is a link to [some other thing][other-thing].\n\nMore text...\n\n[other-thing]: http://example.com/other/thing\n\n\n\nThis style helps keep the documentation source consistent and readable.\n\n\nIf you are hyperlinking to another LISA document, you should use a relative link, and link to the \n.md\n suffix.  For example:\n\n\n[authentication]: ../api-guide/authentication.md\n\n\n\nLinking in this style means you'll be able to click the hyperlink in your Markdown editor to open the referenced document.  When the documentation is built, these links will be converted into regular links to HTML pages.\n\n\n3. Notes\n\n\nIf you want to draw attention to a note or warning, use a pair of enclosing lines, like so:\n\n\n---\n\n**Note:** A useful documentation note.\n\n---", 
            "title": "Contributing to LISA"
        }, 
        {
            "location": "/topics/contributing/#contributing-to-lisa", 
            "text": "There are many ways you can contribute to LISA API.  We'd like it to be a community-led project, so please get involved and help shape the future of the project.", 
            "title": "Contributing to LISA"
        }, 
        {
            "location": "/topics/contributing/#community", 
            "text": "The most important thing you can do to help push the project forward is to be actively involved wherever possible.  Code contributions are often overvalued as being the primary way to get involved in a project, we don't believe that needs to be the case.  If you use LISA, we'd love you to be vocal about your experiences with it - you might consider writing a blog post about using LISA, or publishing a tutorial about your home automation with LISA.  Experiences from beginners can be particularly helpful because you'll be in the best position to assess which bits of LISA are more difficult to understand and work with.", 
            "title": "Community"
        }, 
        {
            "location": "/topics/contributing/#code-of-conduct", 
            "text": "Please keep the tone polite   professional.  First impressions count, so let's try to make everyone feel welcome.  Be mindful in the language you choose.  As an example, in an environment that is heavily male-dominated, posts that start 'Hey guys,' can come across as unintentionally exclusive.  It's just as easy, and more inclusive to use gender neutral language in those situations.", 
            "title": "Code of conduct"
        }, 
        {
            "location": "/topics/contributing/#issues", 
            "text": "It's really helpful if you can make sure to address issues on the correct channel.  Usage questions should be directed to the  Gitter .  Feature requests, bug reports and other issues should be raised on the GitHub  issue tracker .  Some tips on good issue reporting:   When describing issues try to phrase your ticket in terms of the  behavior  you think needs changing rather than the  code  you think need changing.  Search the issue list first for related items, and make sure you're running the latest version of LISA before reporting an issue.  If reporting a bug, then try to include a pull request with a failing test case.  This will help us quickly identify if there is a valid issue, and make sure that it gets fixed more quickly if there is one.  Feature requests will often be closed with a recommendation that they be implemented outside of the core.  Keeping new feature requests implemented as third party libraries allows us to keep down the maintenance overhead of the project, so that the focus can be on continued stability, bugfixes, and great documentation.  Closing an issue doesn't necessarily mean the end of a discussion.  If you believe your issue has been closed incorrectly, explain why and we'll consider if it needs to be reopened.", 
            "title": "Issues"
        }, 
        {
            "location": "/topics/contributing/#triaging-issues", 
            "text": "Getting involved in triaging incoming issues is a good way to start contributing.  Every single ticket that comes into the ticket tracker needs to be reviewed in order to determine what the next steps should be.  Anyone can help out with this, you just need to be willing to   Read through the ticket - does it make sense, is it missing any context that would help explain it better?  Is the ticket reported in the correct place, would it be better suited as a discussion on gitter?  If the ticket is a bug report, can you reproduce it? Are you able to write a failing test case that demonstrates the issue and that can be submitted as a pull request?  If the ticket is a feature request, do you agree with it, and could the feature request instead be implemented as a third party package?  If a ticket hasn't had much activity and it addresses something you need, then comment on the ticket and try to find out what's needed to get it moving again.", 
            "title": "Triaging issues"
        }, 
        {
            "location": "/topics/contributing/#development", 
            "text": "To start developing on LISA API, clone the repo:  git clone git@github.com:project-lisa/lisa-api.git  Changes should broadly follow the  PEP 8  style conventions, and we recommend you set up your editor to automatically indicate non-conforming styles.", 
            "title": "Development"
        }, 
        {
            "location": "/topics/contributing/#testing", 
            "text": "To run the tests, clone the repository, and then:  # Setup the virtual environment\nvirtualenv env\nsource env/bin/activate\npip install -r requirements.txt\n\n# Run the tests\n./runtests.py  Test options  Run using a more concise output style.  ./runtests.py -q  Run the tests using a more concise output style, no coverage, no flake8.  ./runtests.py --fast  Don't run the flake8 code linting.  ./runtests.py --nolint  Only run the flake8 code linting, don't run the tests.  ./runtests.py --lintonly  Run the tests for a given test case.  ./runtests.py MyTestCase  Run the tests for a given test method.  ./runtests.py MyTestCase.test_this_method  Shorter form to run the tests for a given test method.  ./runtests.py test_this_method  Note: The test case and test method matching is fuzzy and will sometimes run other tests that contain a partial string match to the given  command line input.  Running against multiple environments  You can also use the excellent  tox  testing tool to run the tests against all supported versions of Python and Django.  Install  tox  globally, and then simply run:  tox", 
            "title": "Testing"
        }, 
        {
            "location": "/topics/contributing/#pull-requests", 
            "text": "It's a good idea to make pull requests early on.  A pull request represents the start of a discussion, and doesn't necessarily need to be the final, finished submission.  It's also always best to make a new branch before starting work on a pull request.  This means that you'll be able to later switch back to working on another separate issue without interfering with an ongoing pull requests.  It's also useful to remember that if you have an outstanding pull request then pushing new commits to your GitHub repo will also automatically update the pull requests.  GitHub's documentation for working on pull requests is  available here .  Always run the tests before submitting pull requests, and ideally run  tox  in order to check that your modifications are compatible with both Python 2 and Python 3, and that they run properly on all supported versions of Django.  Once you've made a pull request take a look at the Travis build status in the GitHub interface and make sure the tests are running as you'd expect.   Above: Travis build notifications", 
            "title": "Pull requests"
        }, 
        {
            "location": "/topics/contributing/#managing-compatibility-issues", 
            "text": "Sometimes, in order to ensure your code works on various different versions of Django, Python or third party libraries, you'll need to run slightly different code depending on the environment.  Any code that branches in this way should be isolated into the  compat.py  module, and should provide a single common interface that the rest of the codebase can use.", 
            "title": "Managing compatibility issues"
        }, 
        {
            "location": "/topics/contributing/#documentation", 
            "text": "The documentation for LISA API is built from the  Markdown  source files in  the docs directory .  There are many great Markdown editors that make working with the documentation really easy.", 
            "title": "Documentation"
        }, 
        {
            "location": "/topics/contributing/#building-the-documentation", 
            "text": "To build the documentation, install MkDocs with  pip install mkdocs  and then run the following command.  mkdocs build  This will build the documentation into the  site  directory.  You can build the documentation and open a preview in a browser window by using the  serve  command.  mkdocs serve", 
            "title": "Building the documentation"
        }, 
        {
            "location": "/topics/contributing/#language-style", 
            "text": "Documentation should be in American English.  The tone of the documentation is very important - try to stick to a simple, plain, objective and well-balanced style where possible.  Some other tips:   Keep paragraphs reasonably short.  Don't use abbreviations such as 'e.g.' but instead use the long form, such as 'For example'.", 
            "title": "Language style"
        }, 
        {
            "location": "/topics/contributing/#markdown-style", 
            "text": "There are a couple of conventions you should follow when working on the documentation.  1. Headers  Headers should use the hash style.  For example:  ### Some important topic  The underline style should not be used.   Don't do this:  Some important topic\n====================  2. Links  Links should always use the reference style, with the referenced hyperlinks kept at the end of the document.  Here is a link to [some other thing][other-thing].\n\nMore text...\n\n[other-thing]: http://example.com/other/thing  This style helps keep the documentation source consistent and readable.  If you are hyperlinking to another LISA document, you should use a relative link, and link to the  .md  suffix.  For example:  [authentication]: ../api-guide/authentication.md  Linking in this style means you'll be able to click the hyperlink in your Markdown editor to open the referenced document.  When the documentation is built, these links will be converted into regular links to HTML pages.  3. Notes  If you want to draw attention to a note or warning, use a pair of enclosing lines, like so:  ---\n\n**Note:** A useful documentation note.\n\n---", 
            "title": "Markdown style"
        }
    ]
}